# Практическая работа: CRUD-приложение для управления книгами

### Запуск приложения

1. Выполните **.\gradlew clean build.**
2. Выполните **docker-compose -f docker/docker-compose.yml up --build | Tee-Object -FilePath "docker/docker-log.txt"**
3. Можно открыть Swagger в браузере http://localhost:8081/swagger-ui/index.html
   Страница загрузится без пароля.
4. В терминале будут логи о ходе выполнения эндпоинтов со временем исполнения из базы и кэш.
5. Также можно увидеть очистку кэш-ключей в **Redis Insight** для меняющих методов.

### Настройка проекта и окружения

*   **`build.gradle`**:
    *   `Spring Web`: для **разработки REST API с использованием Spring MVC**.
    *   `Spring Data JPA`: для работы с базой данных.
    *   `Validation`: для валидации входящих запросов.
    *   `Spring Boot Starter AOP`: для реализации аспектно-ориентированной логики.
    *   `springdoc-openapi-starter-webmvc-ui`: для **автоматической генерации интерактивной документации и UI для тестирования API (Swagger UI)**.
    *   `PostgreSQL Driver`: драйвер для подключения к нашей базе данных.
    *   `Lombok`: для сокращения шаблонного кода.
    *   `MapStruct`: для автоматического маппинга между DTO и сущностями.

### Инициализация данных из OpenLibrary API с помощю FeignClients

*   **Инициализация данных**: Для первоначального наполнения базы данных мы будем использовать данные из **OpenLibrary API**.
    
    - **Spring** начинает искать интерфейсы, которые помеченны аннотацией @FeignClient.
    
    - **FeignClient** читает аннотации из интерфейса **OpenLibraryClient**. 
    
    - Для метода **searchBooks** он видит @GetMapping("/search.json") и два параметра с @RequestParam.
    
    - Внутри сгенерированного метода searchBooks он размещает код, который: 
       - Берет базовый URL из аннотации @FeignClient ( который, в свою очередь, берется из application.yml). 
       - Добавляет к нему путь  /search.json. 
       - Берет аргументы, переданные в метод (q и limit), и формирует из них строку запроса 
         https://openlibrary.org/search.json?q=subject:history&limit=100
       - Использует встроенный HTTP-клиент для отправки этого собранного GET-запроса по сети. 
       - Получает ответ в виде JSON. 
       - Использует **Jackson** для преобразования этого JSON в Java -объект OpenLibrarySearchResponse. 
       - Возвращает этот объект.
    
    - **Spring** регистрирует **OpenLibraryClient** в своем " контейнере" (Application Context) как бин.
        Теперь для Spring существует готовый к работе объект, который реализует интерфейс  OpenLibraryClient.
    
    Создается **DataInitializer** специальный сервис, который при старте приложения (с профилем `init`) будет запрашивать книги и категории.
    Для его создания и нужен **OpenLibraryClient**.
    Загружаются категории и книги в базу.

### Принцип работы кэширования и инвалидации

   В приложении используется управление кэшем с помощью аннотаций Spring. 
   В качестве хранилища кэша выступает **Redis**. 
   Логика разделена на два основных действия: **кэширование** (сохранение данных) 
   и **инвалидация** (очистка данных).

### 1. Кэширование данных (`@Cacheable`)

   Аннотация `@Cacheable` используется на методах, результаты которых мы хотим сохранить в кэш. 

*   **Если результат найден в кэш**: Метод не выполняется, а результат возвращается напрямую из Redis. Это очень быстро.
*   **Если результат не найден в кэш**: Метод выполняется, его результат сохраняется в Redis, а затем возвращается пользователю.

В проекте кэшируются два метода в `BookServiceImpl`:

#### `findByTitleAndAuthor`

    @Cacheable(value = "bookByTitleAndAuthor", key = "#title + #author")
    public Book findByTitleAndAuthor(String title, String author)

*   **Кэш**: `bookByTitleAndAuthor`
*   **Ключ**: Генерируется путем конкатенации названия и автора книги (например, `Война и мир+Лев Толстой`).
*   **Поведение**: При первом поиске книги по названию и автору, найденная книга сохраняется в Redis. 
      Все последующие запросы с теми же параметрами будут возвращать книгу из кэша, не обращаясь к базе данных.

#### `findAllByCategoryName`

    @Cacheable(value = "booksByCategory", key = "#categoryName")
    public List<Book> findAllByCategoryName(String categoryName)

*   **Кэш**: `booksByCategory`
*   **Ключ**: Имя категории (например, `History`).
*   **Поведение**: При первом запросе списка книг для определенной категории, этот список сохраняется в Redis. 
      Все последующие запросы для этой же категории будут возвращать данные из кэша.

---

### 2. Инвалидация кэша (`@CacheEvict`)

   Чтобы данные в кэше не становились неактуальными, кэш необходимо очищать каждый раз, 
   когда мы изменяем данные в базе. Для этого используется аннотация `@CacheEvict`.

   В проекте используется стратегия полной очистки кэша с помощью параметра `allEntries = true`. 
   Это означает, что при вызове метода **удаляются все записи** из указанного кэша, а не какая-то одна.

   Эта логика реализована с помощью аннотации `@Caching` и применяется к методам, изменяющим данные: `save`, `update` и `deleteById`.

    @Caching(evict = {
        @CacheEvict(value = "bookByTitleAndAuthor", allEntries = true),
        @CacheEvict(value = "booksByCategory", allEntries = true)
    })
    // Эта аннотация стоит над методами save(), update() и deleteById()

*   **Поведение**: После успешного выполнения любого из этих трёх методов (`save`, `update` или `deleteById`) 
      Spring **полностью очищает оба кэша**: `bookByTitleAndAuthor` и `booksByCategory`.

      Таким образом, система гарантирует, что кэш ускоряет чтение данных, но не отдает устаревшую информацию после их изменения.
