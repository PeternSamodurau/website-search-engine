# 6.5 Практическая работа: Асинхронная система на Kafka

Cоздали микросервисную систему, где сервисы не общаются друг с другом напрямую. 
Вместо этого они общаются асинхронно через — **Apache Kafka**. 

## Наши "действующие лица":

1.  **`order-service` (Сервис Заказов):**
    *   **Роль:** Входная точка для user. 
        Его единственная задача — принять заказ и немедленно "дать знать" о нем в Kafka. 
        Он не ждет, пока заказ обработается, что делает его очень быстрым.
    *   **Технически:** Это Spring Boot приложение с REST-контроллером.

2.  **`order-status-service` (Сервис Статусов):**
    *   **Роль:** Рабочая лошадка. Он постоянно слушает Kafka, и как только слышит о новом заказе, он его "подхватывает", выполняет какую-то логику (в нашем случае — просто меняет статус) и сообщает о результате в другую "комнату" в Kafka.
    *   **Технически:** Это Spring Boot приложение без REST-контроллера, только с Kafka-слушателем и Kafka-отправителем.

3.  **`common-dto` (Общие Данные):**
    *   **Роль:** "Общий язык" или "словарь". Чтобы `order-service` и `order-status-service` понимали друг друга, они должны использовать одинаковые форматы сообщений. Этот модуль и содержит описание этих форматов.
    *   **Технически:** Это простая Java-библиотека (JAR-файл), которая будет подключена к обоим сервисам.

## Пошаговый сценарий работы (согласно ТЗ)

Давайте проследим путь одного заказа через всю систему:

1.  **Шаг 1: Клиент отправляет заказ**
    *   Внешний пользователь (или вы через Postman) отправляет `POST`-запрос на эндпоинт в `order-service`. Например: `POST /api/orders` с телом `{"product": "Laptop", "quantity": 1}`.

2.  **Шаг 2: `order-service` принимает заказ**
    *   REST-контроллер в `order-service` принимает этот запрос.
    *   Он **не обрабатывает** заказ. Он просто создает Java-объект `OrderEvent` из нашего модуля `common-dto`.

3.  **Шаг 3: `order-service` отправляет событие в Kafka**
    *   `order-service` с помощью `KafkaTemplate` отправляет этот объект `OrderEvent` в первый топик Kafka, который мы назовем `order_topic`.
    *   Сразу после отправки `order-service` отвечает клиенту "200 OK, ваш заказ принят в обработку". Его работа на этом закончена.

4.  **Шаг 4: `order-status-service` получает событие**
    *   `order-status-service` постоянно слушает `order_topic`. Как только там появляется новое сообщение, его `KafkaListener` "просыпается" и забирает его.
    *   Kafka автоматически преобразует JSON-сообщение обратно в Java-объект `OrderEvent`.

5.  **Шаг 5: `order-status-service` обрабатывает заказ**
    *   Сервис выполняет свою бизнес-логику. В нашем случае, он просто создает новый объект `OrderStatusEvent` (тоже из `common-dto`) и устанавливает ему статус, например, `CREATED`.

6.  **Шаг 6: `order-status-service` сообщает о новом статусе**
    *   `order-status-service` с помощью `KafkaTemplate` отправляет объект `OrderStatusEvent` во второй топик Kafka, который мы назовем `order_status_topic`.

## Преимущества такой архитектуры

*   **Разделение ответственности:** Каждый сервис делает только свою работу. `order-service` быстр на прием, `order-status-service` может долго обрабатывать заказ, не мешая приему новых.
*   **Масштабируемость:** Если обработка заказов станет медленной, мы можем запустить несколько экземпляров `order-status-service`, и они будут разбирать сообщения из `order_topic` параллельно.
*   **Отказоустойчивость:** Если `order-status-service` упадет, `order-service` продолжит принимать заказы, и они будут копиться в Kafka. Когда сервис поднимется, он продолжит обработку с того места, где остановился.

---
Теперь, когда у нас есть рабочий каркас, мы можем приступить к наполнению его логикой: созданию DTO, контроллеров и слушателей.
