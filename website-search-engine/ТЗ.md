<a id="toc"></a>
# Оглавление

- [1.Описание итогового проекта](#1описание-итогового-проекта)
    - [Над чем предстоит работать](#над-чем-предстоит-работать)
    - [Вы научитесь:](#вы-научитесь)
    - [Какие материалы необходимо использовать для выполнения проекта](#какие-материалы-необходимо-использовать-для-выполнения-проекта)
- [2.Критерии оценивания](#2критерии-оценивания)
    - [Функционал](#функционал)
        - [Обязательные требования](#обязательные-требования)
        - [Дополнительно](#дополнительно)
    - [Качество кода](#качество-кода)
        - [Обязательные требования](#обязательные-требования-0)
        - [Дополнительно](#дополнительно-0)
    - [Качество демонстрации работы](#качество-демонстрации-работы)
        - [Обязательные требования](#обязательные-требования-1)
        - [Дополнительно](#дополнительно-1)
- [3.Техническая спецификация](#3техническая-спецификация)
    - [Описание веб-интерфейса](#описание-веб-интерфейса)
    - [Структура базы данных](#структура-базы-данных)
        - [site — информация о сайтах и статусах их индексации](#site--информация-о-сайтах-и-статусах-их-индексации)
        - [page — проиндексированные страницы сайта](#page--проиндексированные-страницы-сайта)
        - [lemma — леммы, встречающиеся в текстах (см. справочно: лемматизация).](#lemma--леммы-встречающиеся-в-текстах-см-справочно-лемматизация)
        - [index — поисковый индекс](#index--поисковый-индекс)
    - [Спецификация API](#спецификация-api)
        - [Запуск полной индексации — GET /api/startIndexing](#запуск-полной-индексации--get-apistartindexing)
        - [Остановка текущей индексации — GET /api/stopIndexing](#остановка-текущей-индексации--get-apistopindexing)
        - [Добавление или обновление отдельной страницы — POST /api/indexPage](#добавление-или-обновление-отдельной-страницы--post-apiindexpage)
        - [Статистика — GET /api/statistics](#статистика--get-apistatistics)
        - [Получение данных по поисковому запросу — GET /api/search](#получение-данных-по-поисковому-запросу--get-apisearch)
    - [Ответы в случае ошибок](#ответы-в-случае-ошибок)
- [4.Основное техническое задание](#4основное-техническое-задание)
    - [Разработка локального поискового движка по сайту](#разработка-локального-поискового-движка-по-сайту)
    - [Принципы работы поискового движка](#принципы-работы-поискового-движка)
    - [Рекомендации по работе над проектом](#рекомендации-по-работе-над-проектом)
    - [Рекомендации по технической реализации](#рекомендации-по-технической-реализации)
- [Описание проекта](#описание-проекта)
- [Этап 1. Подготовка](#этап-1-подготовка)
    - [Цель](#цель)
    - [Что нужно сделать](#что-нужно-сделать)
- [Этап 2. Система обхода веб-страниц](#этап-2-система-обхода-веб-страниц)
    - [Цель](#цель-0)
    - [Что нужно сделать](#что-нужно-сделать-0)
        - [Как проверить работу программы](#как-проверить-работу-программы)
- [Этап 3. Система индексации веб-страниц](#этап-3-система-индексации-веб-страниц)
    - [Описание](#описание)
        - [Цель](#цель-1)
        - [Что нужно сделать](#что-нужно-сделать-1)
        - [Как проверить работу программы](#как-проверить-работу-программы-0)
- [Этап 4. Система поиска](#этап-4-система-поиска)
    - [Цель](#цель-2)
    - [Что нужно сделать](#что-нужно-сделать-2)
        - [Как проверить работу программы](#как-проверить-работу-программы-1)
- [Этап 5. Публикация проекта на GitHub](#этап-5-публикация-проекта-на-github)
    - [Цель](#цель-3)
    - [Что нужно сделать](#что-нужно-сделать-3)

<br>

<a name="1описание-итогового-проекта"></a>
# 1.Описание итогового проекта

<a name="над-чем-предстоит-работать"></a>
## Над чем предстоит работать

Вам предстоит разработать поисковый движок по сайту — приложение, которое позволяет индексировать страницы и осуществлять по ним быстрый поиск. Движок разрабатывается на фреймворке Spring, функционал фреймворка в проекте используется по минимуму — на том уровне, который вы прошли в модуле по Spring.

Знаний, полученных в рамках курса, вам будет вполне достаточно для реализации этого проекта, прибегать к внешним источникам не придётся. В этом проекте вы примените практически все полученные в курсе знания по ООП, коллекциям, работе с файлами и сетью, работе с базами данных и многопоточности. Будет мало веб-разработки и много алгоритмического кода.

<a name="вы-научитесь"></a>
## Вы научитесь:

- реализовать многопоточное приложение, которое обходит все страницы сайта начиная с главной;
- работать с библиотекой лемматизации слов;
- реализовать систему индексации страниц сайта — систему, которая позволит подсчитывать слова на страницах сайта и по поисковому запросу определять наиболее релевантные (соответствующие поисковому запросу) страницы;
- реализовать систему поиска информации с использованием созданного поискового индекса;
- создавать из получившейся программы веб-приложение, которое будет индексировать несколько сайтов.

<a name="какие-материалы-необходимо-использовать-для-выполнения-проекта"></a>
## Какие материалы необходимо использовать для выполнения проекта

Для корректного выполнения итогового проекта вам пригодятся вебинар и видео по теме Java-фреймворк Spring, также советуем руководствоваться техническим заданием.


[К оглавлению](#toc)

<a name="2критерии-оценивания"></a>
# 2.Критерии оценивания

<a name="функционал"></a>
## Функционал

<a name="обязательные-требования"></a>
### Обязательные требования
- Все три страницы открываются.
- На странице DASHBOARD выводится статистика по сайтам: список сайтов, а по каждому сайту — информация о количестве проиндексированных страниц и лемм, соответствующая реальности.
- На странице MANAGEMENT работают запуск и остановка индексации.
- На странице SEARCH работает поиск как по всем сайтам, так и по каждому отдельному. В поисковой выдаче выводится список найденных страниц, соответствующих запросу. Каждая страница выводится в виде её заголовка и сниппета, содержащего одно или несколько упоминаний слов из поискового запроса.
- Сниппеты выводятся в виде понятных текстов, не содержащих HTML-теги. При клике по любому результату в новой вкладке открывается соответствующая веб-страница на том сайте, к которому относится этот результат.

<a name="дополнительно"></a>
### Дополнительно
- Работают добавление и обновление контента отдельной страницы.
- Правильно работает постраничная навигация результатов поиска.
- Результаты поиска выдаются в порядке убывания релевантности, в соответствии с алгоритмом, описанным в ТЗ.

<a name="качество-кода"></a>
## Качество кода

<a name="обязательные-требования-0"></a>
### Обязательные требования
- Наименование классов, методов, переменных должно соответствовать Java Code Style. CamelCase — для классов, lowerCamelCase — для методов и переменных, отсутствие сокращений и транслита.

<a name="дополнительно-0"></a>
### Дополнительно
- Соблюдены рекомендации по разделению Spring-приложения на файлы.
- Используются сервисы, «плоские» контроллеры, DTO и модели.
- Размер методов — не более 30 строк.
- Дублирования кода не должно быть. «Запахи»: однотипные методы, одинаковые строки в if-блоках, одинаковые классы.
- Содержание переменных и действия методов соответствуют названиям.
- Большая вложенность циклов for и while.
- Большая вложенность ветвлений if и switch, тернарные операторы.

<a name="качество-демонстрации-работы"></a>
## Качество демонстрации работы

<a name="обязательные-требования-1"></a>
### Обязательные требования
- Проект доступен для публичного просмотра по URL, открывается и работает.

<a name="дополнительно-1"></a>
### Дополнительно
- Готова работа для показа работодателю. Не должно быть лишних файлов в репозитории (скомпилированные файлы, настройки среды разработки, временные файлы). Написано README.md с описанием проекта и инструкциями для запуска.
- Демонстрация работы. Участник курса самостоятельно рассказывает и показывает функционал проекта. Описывает процесс разработки. Отвечает на вопросы по реализации кода.


[К оглавлению](#toc)

<a name="3техническая-спецификация"></a>
# 3.Техническая спецификация

<a name="описание-веб-интерфейса"></a>
## Описание веб-интерфейса

Веб-интерфейс (frontend-составляющая) проекта представляет собой одну веб-страницу с тремя вкладками:

*   **Dashboard.** Эта вкладка открывается по умолчанию. На ней отображается общая статистика по всем сайтам, а также детальная статистика и статус по каждому из сайтов (статистика, получаемая по запросу `/api/statistics`).
*   **Management.** На этой вкладке находятся инструменты управления поисковым движком — запуск и остановка полной индексации (переиндексации), а также возможность добавить (обновить) отдельную страницу по ссылке.
*   **Search.** Эта страница предназначена для тестирования поискового движка. На ней находится поле поиска, выпадающий список с выбором 1 сайта для поиска, а при нажатии на кнопку «Найти» выводятся результаты поиска (по API-запросу `/api/search`):

Вся информация на вкладки подгружается путём запросов к API вашего приложения. При нажатии кнопок также отправляются запросы.

<a name="структура-базы-данных"></a>
## Структура базы данных

<a name="site--информация-о-сайтах-и-статусах-их-индексации"></a>
### site — информация о сайтах и статусах их индексации

*   `id` INT NOT NULL AUTO_INCREMENT;
*   `status` ENUM('INDEXING', 'INDEXED', 'FAILED') NOT NULL — текущий статус полной индексации сайта, отражающий готовность поискового движка осуществлять поиск по сайту — индексация или переиндексация в процессе, сайт полностью проиндексирован (готов к поиску) либо его не удалось проиндексировать (сайт не готов к поиску и не будет до устранения ошибок и перезапуска индексации);
*   `status_time` DATETIME NOT NULL — дата и время статуса (в случае статуса INDEXING дата и время должны обновляться регулярно при добавлении каждой новой страницы в индекс);
*   `last_error` TEXT — текст ошибки индексации или NULL, если её не было;
*   `url` VARCHAR(255) NOT NULL — адрес главной страницы сайта;
*   `name` VARCHAR(255) NOT NULL — имя сайта.

<a name="page--проиндексированные-страницы-сайта"></a>
### page — проиндексированные страницы сайта

*   `id` INT NOT NULL AUTO_INCREMENT;
*   `site_id` INT NOT NULL — ID веб-сайта из таблицы `site`;
*   `path` TEXT NOT NULL — адрес страницы от корня сайта (должен начинаться со слэша, например: `/news/372189/`);
*   `code` INT NOT NULL — код HTTP-ответа, полученный при запросе страницы (например, 200, 404, 500 или другие);
*   `content` MEDIUMTEXT NOT NULL — контент страницы (HTML-код).

По полю `path` должен быть установлен индекс, чтобы поиск по нему был быстрым, когда в нём будет много ссылок. Индексы рассмотрены в курсе «Язык запросов SQL».

<a name="lemma--леммы-встречающиеся-в-текстах-см-справочно-лемматизация"></a>
### lemma — леммы, встречающиеся в текстах (см. справочно: лемматизация).

*   `id` INT NOT NULL AUTO_INCREMENT;
*   `site_id` INT NOT NULL — ID веб-сайта из таблицы `site`;
*   `lemma` VARCHAR(255) NOT NULL — нормальная форма слова (лемма);
*   `frequency` INT NOT NULL — количество страниц, на которых слово встречается хотя бы один раз. Максимальное значение не может превышать общее количество слов на сайте.

<a name="index--поисковый-индекс"></a>
### index — поисковый индекс

*   `id` INT NOT NULL AUTO_INCREMENT;
*   `page_id` INT NOT NULL — идентификатор страницы;
*   `lemma_id` INT NOT NULL — идентификатор леммы;
*   `rank` FLOAT NOT NULL — количество данной леммы для данной страницы.

<a name="спецификация-api"></a>
## Спецификация API

<a name="запуск-полной-индексации--get-apistartindexing"></a>
### Запуск полной индексации — GET /api/startIndexing

Метод запускает полную индексацию всех сайтов или полную переиндексацию, если они уже проиндексированы. Если в настоящий момент индексация или переиндексация уже запущена, метод возвращает соответствующее сообщение об ошибке.

**Параметры:**
Метод без параметров

**Формат ответа в случае успеха:**

```json
{ 'result': true }
```

**Формат ответа в случае ошибки:**

```json
{ 'result': false, 'error': "Индексация уже запущена" }
```

<a name="остановка-текущей-индексации--get-apistopindexing"></a>
### Остановка текущей индексации — GET /api/stopIndexing

Метод останавливает текущий процесс индексации (переиндексации). Если в настоящий момент индексация или переиндексация не происходит, метод возвращает соответствующее сообщение об ошибке.

**Параметры:**

Метод без параметров.

**Формат ответа в случае успеха:**

```json
{ 'result': true }
```

**Формат ответа в случае ошибки:**

```json
{ 'result': false, 'error': "Индексация не запущена" }
```

<a name="добавление-или-обновление-отдельной-страницы--post-apiindexpage"></a>
### Добавление или обновление отдельной страницы — POST /api/indexPage

Метод добавляет в индекс или обновляет отдельную страницу, адрес которой передан в параметре. Если адрес страницы передан неверно, метод должен вернуть соответствующую ошибку.

**Параметры:**

*   `url` — адрес страницы, которую нужно переиндексировать.

**Формат ответа в случае успеха:**

```json
{ 'result': true }
```

**Формат ответа в случае ошибки:**

```json
{ 'result': false, 'error': "Данная страница находится за пределами сайтов, указанных в конфигурационном файле" }
```

<a name="статистика--get-apistatistics"></a>
### Статистика — GET /api/statistics

Метод возвращает статистику и другую служебную информацию о состоянии поисковых индексов и самого движка. Если ошибок индексации того или иного сайта нет, задавать ключ `error` не нужно.

**Параметры:**

Метод без параметров.

**Формат ответа:**

```json
{
  'result': true,
  'statistics': {
    "total": {
      "sites": 10,
      "pages": 436423,
      "lemmas": 5127891,
      "indexing": true
    },
    "detailed": [
      {
        "url": "http://www.site.com",
        "name": "Имя сайта",
        "status": "INDEXED",
        "statusTime": 1600160357,
        "error": "Ошибка индексации: главная страница сайта недоступна",
        "pages": 5764,
        "lemmas": 321115
      },
      ...
    ]
  }
}
```

<a name="получение-данных-по-поисковому-запросу--get-apisearch"></a>
### Получение данных по поисковому запросу — GET /api/search

Метод осуществляет поиск страниц по переданному поисковому запросу (параметр `query`). Чтобы выводить результаты порционно, также можно задать параметры `offset` (сдвиг от начала списка результатов) и `limit` (количество результатов, которое необходимо вывести). В ответе выводится общее количество результатов (`count`), не зависящее от значений параметров `offset` и `limit`, и массив `data` с результатами поиска. Каждый результат — это объект, содержащий свойства результата поиска (см. ниже структуру и описание каждого свойства). Если поисковый запрос не задан или ещё нет готового индекса (сайт, по которому ищем, или все сайты сразу не проиндексированы), метод должен вернуть соответствующую ошибку (см. ниже пример). Тексты ошибок должны быть понятными и отражать суть ошибок.

**Параметры:**

*   `query` — поисковый запрос;
*   `site` — сайт, по которому осуществлять поиск (если не задан, поиск должен происходить по всем проиндексированным сайтам); задаётся в формате адреса, например: `http://www.site.com` (без слэша в конце);
*   `offset` — сдвиг от 0 для постраничного вывода (параметр необязательный; если не установлен, то значение по умолчанию равно нулю);
*   `limit` — количество результатов, которое необходимо вывести (параметр необязательный; если не установлен, то значение по умолчанию равно 20).

**Формат ответа в случае успеха:**

```json
{
  'result': true,
  'count': 574,
  'data': [
    {
      "site": "http://www.site.com",
      "siteName": "Имя сайта",
      "uri": "/path/to/page/6784",
      "title": "Заголовок страницы, которую выводим",
      "snippet": "Фрагмент текста, в котором найдены совпадения, <b>выделенные жирным</b>, в формате HTML",
      "relevance": 0.93362
    },
    ...
  ]
}
```

**Формат ответа в случае ошибки:**

```json
{ 'result': false, 'error': "Задан пустой поисковый запрос" }
```

<a name="ответы-в-случае-ошибок"></a>
## Ответы в случае ошибок

Во всех командах API необходимо реализовать корректные ответы в случае возникновения ошибок. Любой метод API может возвращать ошибку, если она произошла. В этом случае ответ должен выглядеть стандартным образом:

```json
{ 'result': false, 'error': "Указанная страница не найдена" }
```

Такие ответы должны сопровождаться соответствующими статус-кодами. Желательно ограничиться использованием кодов 400, 401, 403, 404, 405 и 500 при возникновении соответствующих им типов ошибок.



[К оглавлению](#toc)

<a name="4основное-техническое-задание"></a>
# 4.Основное техническое задание

Вы почти закончили прохождение курса и дошли до его завершающего блока, большая часть теории и практики осталась позади. Мы гордимся вашим трудолюбием и упорством! Теперь осталось совсем немного — выполнить и презентовать итоговый проект.

Итоговый проект нужен, чтобы вы закрепили все полученные на курсе знания и навыки, самостоятельно создав крупный и работоспособный продукт. Он станет отличным кейсом для вашего портфолио, который можно будет смело показывать потенциальным работодателям.

Опыт самостоятельного выполнения крупных комплексных проектов, таких как данный итоговый проект, даст вам значительные преимущества в поиске работы по профессии.

Желаем успехов в работе над проектом! Уверены, будет интересно! :)

<a name="разработка-локального-поискового-движка-по-сайту"></a>
## Разработка локального поискового движка по сайту

Перед вами подробное описание будущего проекта. В этом техническом задании есть всё, что вам нужно, чтобы справиться с поставленной задачей.

Мы рассчитываем, что вы, приступая к выполнению этого проекта, прошли курс по языку Java, выполнили в нём практические работы, получили базовый уровень самостоятельности и обладаете следующими навыками:

*   можете писать код на Java;
*   владеете основными элементами синтаксиса языка Java;
*   умеете писать понятный и поддерживаемый код;
*   умеете работать с числами, строками, датами и коллекциями;
*   умеете создавать собственные классы, абстрактные классы и интерфейсы;
*   умеете работать с файлами разных форматов — создавать, читать и удалять при помощи программного кода файлы форматов CSV, HTML и JSON;
*   можете разрабатывать многопоточные приложения;
*   владеете механизмами работы с исключениями и логами;
*   умеете создавать несложные приложения на Spring Boot;
*   умеете находить решения проблем в интернете.

[К оглавлению](#toc)

<a name="описание-проекта"></a>
# Описание проекта

Вы пришли работать в отдел разработки программного обеспечения недавно созданного информационно-новостного портала, на котором каждый день выходят новости о событиях в мире и статьи разных авторов. Руководитель поручил вам реализацию собственного поискового движка, который помогает посетителям сайта быстро находить информацию, используя поле поиска.

Ваши коллеги уже попробовали существующие поисковые движки: лучшим из них оказался Яндекс Сервер, который можно установить на своём сервере и использовать для поиска по своим сайтам или по одному из них. К сожалению, движок прекратил существовать как отдельный сервис. Ваше руководство решило реализовать собственный поиск и алгоритм, принципы работы которого при необходимости можно менять и развивать.

Задачи по реализации поискового движка будут выдаваться вам постепенно. Руководство хочет убедиться, что придуманный алгоритм работает верно, и не планирует перегружать вас большим техническим заданием, к которому сложно подступиться.

Поисковый движок должен представлять из себя Spring-приложение (JAR-файл, запускаемый на любом сервере или компьютере), работающее с локально установленной базой данных MySQL, имеющее простой веб-интерфейс и API, через который им можно управлять и получать результаты поисковой выдачи по запросу.

<a name="принципы-работы-поискового-движка"></a>
## Принципы работы поискового движка

1.  В конфигурационном файле перед запуском приложения задаются адреса сайтов, по которым движок должен осуществлять поиск.
2.  Поисковый движок должен самостоятельно обходить все страницы заданных сайтов и индексировать их (создавать так называемый индекс) так, чтобы потом находить наиболее релевантные страницы по любому поисковому запросу.
3.  Пользователь присылает запрос через API движка. Запрос — это набор слов, по которым нужно найти страницы сайта.
4.  Запрос определённым образом трансформируется в список слов, переведённых в базовую форму. Например, для существительных — именительный падеж, единственное число.
5.  В индексе ищутся страницы, на которых встречаются все эти слова.
6.  Результаты поиска ранжируются, сортируются и отдаются пользователю.

Ниже вы найдёте все технические подробности реализации поискового движка, которые помогут вам создать работающее приложение. Они разбиты на несколько небольших этапов. По каждому этапу подробно расписано, что необходимо сделать и как проверить конечный результат.

На первом этапе нужно загрузить из репозитория заготовку проекта (простого приложения на Spring Boot). В этой заготовке реализованы полезные примеры и фрагменты будущего поискового движка, которые вам предстоит самостоятельно дополнить по настоящему техническому заданию. Мы также реализовали и включили в этот проект frontend-составляющую, чтобы вы могли полностью сконцентрироваться на backend.

Для вашего удобства техническая спецификация проекта собрана в отдельный документ, в котором содержатся:

*   описание веб-интерфейса;
*   структура таблиц базы данных;
*   документация по командам API.

<a name="рекомендации-по-работе-над-проектом"></a>
## Рекомендации по работе над проектом

*   Прочитайте это техническое задание и просмотрите техническую спецификацию проекта. Составьте представление о будущем проекте и его общей структуре.
*   Выполнение этого проекта рассчитано суммарно на 40–60 часов работы. Распланируйте свой график таким образом, чтобы выполнить проект небольшими подходами по 2–3 часа и завершить его в течение одного месяца. Такой метод работы будет гораздо эффективнее, чем непрерывная работа в течение длительного времени. Не забывайте отдыхать, чтобы не выгореть и работать с интересом.
*   Прежде чем отправлять готовый проект на проверку куратору (а в реальной работе — тестировщику), проверьте его самостоятельно. Используйте для этого рекомендации по проверке, которые мы даём в конце каждого этапа.
*   Попросите нескольких друзей или коллег протестировать проект вместе с вами, если у вас есть такая возможность. Обращайте внимание на все их замечания и комментарии. Возможно, вы захотите внести в продукт небольшие доработки, которые значительно улучшат качество и скорость его работы.

<a name="рекомендации-по-технической-реализации"></a>
## Рекомендации по технической реализации

1.  Придерживайтесь принципов «чистого» кода, их соблюдение сделает ваш код более понятным и поддерживаемым:
    *   Избегайте повторов кода.
    *   Именуйте переменные, методы и классы в соответствии с правилами именования в Java, в частности, чтобы их имена отражали назначение.
    *   Используйте методы не длиннее 30 строк кода, не принимающие более трёх параметров (если требуется больше, то их нужно объединять в класс, коллекцию).
    *   Избегайте слишком высокой вложенности кода: старайтесь писать код с вложенностью не более двух уровней:

        ```java
        for(int i = 0; i < data.size(); i++) {
           if(data.getItem(i).equals(VALUE)) {
              doSomething(VALUE);
           } else {
              doSomeAnotherAction();
           }
        }
        ```

    *   По возможности упрощайте код. Например этот код:

        ```java
        public boolean isFinalResult() {
           if(isFinished && result < 10) {
              return true;
           }
           return false;
        }
        ```

        можно упростить до:

        ```java
        public boolean isFinalResult() {
           return isFinished && result < 10;
        }
        ```

    *   Не забывайте для упрощения кода использовать тернарный оператор. Например, вместо кода:

        ```java
        public String getCondition(int value) {
           if(value > 10) {
              return "WHERE value = 10";
           }
           return "WHERE value = " + value;
        }
        ```

        можно написать:

        ```java
        public String getCondition(int value) {
           return "WHERE value = " + (value > 10 ? 10 : value);
        }
        ```

    *   Если идёт сравнение, то часто min/max — отличный выбор:

        ```java
        public String getCondition(int value) {
           return "WHERE value = " + Math.min(10, value);
        }
        ```

    *   По возможности не пишите комментарии в коде методов. По коду должно быть понятно, что он делает. Если вы используете сложное регулярное выражение, назовите переменную так, чтобы было понятно, что это регулярное выражение описывает. Если метод сложный, то декомпозировать на более мелкие части лучше, чем писать многострочные комментарии. Также нежелательно писать JavaDoc в начале проекта: их стоит писать для блоков кода, которые не потребуют изменений в дальнейшем, чтобы и документация, и описание методов соответствовали поведению.
2.  «Узким местом» в производительности приложений является работа с базой данных. Рекомендуем при работе с базой данных:
    *   Избегать запросов без ограничений, то есть не получать все ссылки или все слова из какой-либо таблицы и, тем более, из запроса с оператором JOIN. Получайте только те данные, которые вам необходимы. Фильтруйте, сортируйте, ограничивайте количество данных в ответе на уровне базы данных — в самих запросах к ней.
    *   Избегать многократных запросов в циклах. В таких случаях ищите варианты написания единого запроса.

[К оглавлению](#toc)

<a name="этап-1-подготовка"></a>
# Этап 1. Подготовка

<a name="цель"></a>
### Цель

Скачать, запустить и изучить заготовку проекта, в котором вы будете реализовывать приложение, создать базу данных и подключить к ней проект.

<a name="что-нужно-сделать"></a>
### Что нужно сделать

*   Установите на свой компьютер JDK и среду разработки IntelliJ IDEA, если они ещё не установлены.
*   Загрузите проект-заготовку из Git-репозитория.
*   Запустите приложение и откройте его через браузер по адресу: http://localhost:8080/. Вы должны увидеть страницу следующего вида:

    !Пример внешнего вида страницы

*   Внимательно изучите структуру этого проекта и то, как он работает.
    *   Проект реализован на основе Spring Boot и сборщика Maven, поэтому в файле pom.xml заданы несколько зависимостей, подключающих сам Spring Boot, шаблонизатор и библиотеку Lombok, предоставляющую возможности использования удобных аннотаций. Вы изучали эти темы в модулях «Разработка веб-приложений» и «Особенности ООП в Java».
    *   Все классы находятся в папке src/main/java/searchengine. Это необходимо для правильной сборки и запуска приложения с помощью Maven.
    *   Запуск приложения начинается с метода main, находящегося в классе Application, помеченном аннотацией `@SpringBootApplication`.
    *   Поскольку Spring Boot включает в себя не только фреймворк Spring, но и веб-сервер Apache Tomcat, запущенное приложение сразу начинает «слушать» порт 8080 (по умолчанию) и при переходе в браузере по адресу http://localhost:8080/ начинает открываться главная страница приложения. Ниже мы детально разберём, как сделать, чтобы открывалась такая страница.
    *   Сама веб-страница (файл index.html) размещена в папке resources/templates, поэтому её можно подключить в контроллере с помощью шаблонизатора Thymeleaf.
    *   В папке controllers есть два контроллера: DefaultController и ApiController. Собственно, в DefaultController создан метод index с аннотацией `@RequestMapping("/")`, которая означает, что этот метод должен вызываться при запросе к главной странице приложения.
    *   В самом методе index написан `return "index"`. Поскольку в проекте работает шаблонизатор Thymeleaf, такой код автоматически подключает и возвращает в качестве ответа код одноимённой веб-страницы (index.html), лежащей в папке resources/templates.
*   Рассмотрим работу запроса к ApiController. Зайдите в браузер на главную страницу приложения, откройте WebInspector (нажатием на странице клавиши <F12>) и вкладку Network:
    *   Обновите веб-страницу. Вы увидите на этой вкладке, как она загружается:
    *   В начале загружается сама страница (первая строка localhost), затем загружаются её компоненты: шрифты (файлы *.woff2), изображения (файлы *.svg) и скрипты (файлы *.js). В проекте они все размещены в папках внутри папки resources/static/assets.
    *   Кроме того, происходит запрос statistics. Нажмите на него, и вы увидите, по какому пути происходит этот запрос:
    *   Нажмите справа на вкладку Preview, и вы увидите ответ, который приходит от приложения на веб-страницу. Разверните его и внимательно изучите. Он полностью соответствует формату ответа команды API statistics, описанному в технической спецификации.
    *   Когда вы будете реализовывать остальные команды API, мы рекомендуем вам также использовать WebInspector для просмотра запросов веб-страницы к приложению и содержимого получаемых ответов. Это очень удобно.
    *   Посмотрим, как работает ApiController и как он формирует ответ на запрос /api/statistics.
    *   Обратите внимание, что контроллер помечен двумя аннотациями: `@RestController` и `@RequestMapping("/api")`. Первая означает, что этот контроллер будет работать по стандарту REST и, в частности, возвращать ответы в формате JSON. Вторая устанавливает префикс в пути запроса: все запросы, начинающиеся с /api, будут направляться на методы этого контроллера.
    *   В контроллере также создан объект класса StatisticsService (на самом деле это — интерфейс, см. ниже) и в конструкторе ему присваивается передаваемое значение. Это сервис, который отвечает за формирование ответа на запрос /api/statistics. Ниже мы рассмотрим его детально.
    *   В методе контроллера, который помечен аннотацией `@GetMapping("/statistics")` и, следовательно, отвечает на соответствующий GET-запрос, формируется успешный ответ:

        ```java
        return ResponseEntity.ok(...);
        ```

        Это — короткая запись, формирующая ответ в формате JSON с HTTP-кодом 200. В качестве параметра в метод ok передаётся результат выполнения метода getStatistics, вызываемого у объекта statisticsService.
    *   Теперь давайте посмотрим на сервис. Все сервисы в приложениях на основе Spring Boot принято размещать в папке services. В ней размещён интерфейс StatisticsService и класс, который его имплементирует. Но перед этим — немного теории.
    *   Приложения на основе фреймворка Spring обычно содержат три слоя реализации:
        *   **Presentation**. В этом слое находятся контроллеры. Слой «общается» с пользователями, в нашем случае — принимает запросы по API и отдаёт ответы.
        *   **Business**. В этом слое реализуется бизнес-логика приложения. Она как раз содержится в классах-сервисах. Этот слой ничего «не знает» о слое Presentation и никак от него не зависит. Если мы изменим что-то в слое Presentation, это никак не повлияет на слой Business.
        *   **Data Access**. Этот слой отвечает за хранение данных и, в частности, за подключение к БД. Он также ничего «не знает» о других слоях и не зависит от них.
            Каждый слой занимается только своими задачами и реализация одного слоя не должна зависеть от реализации другого. Например, контроллер должен получать данные от пользователя и вызывать нужный сервис, не более. Все расчёты и проверки должны происходить в классах-сервисах.
            Если посмотреть на слои данного приложения, то увидим не только сами классы, но ещё и интерфейсы между ними.
            Интерфейсы нужны, чтобы слои приложения не зависели от реализации классов. Это значит, что сервисы и контроллеры могут меняться независимо, заменяться, и это не будет влиять на другие слои.
    *   Теперь вернёмся к нашему приложению. В классе StatisticsServiceImpl сначала происходит подключение данных из файла конфигурации. Файл конфигурации (application.yaml) лежит в папке resources приложения и содержит список сайтов с их названиями и адресами. Откройте его и посмотрите, какие параметры в нём написаны.
    *   Чтобы данные из файла конфигурации попали в сервис, в приложении сделано следующее:
        *   Реализованы классы Site и SiteList. Они находятся в папке config. У них есть lombok-аннотации `@Setter` и `@Getter`, которые добавляют в классы сеттеры и геттеры для всех полей.
        *   Класс SitesList помечен аннотациями `@Component` и `@ConfigurationProperties(prefix = "indexing-settings")`. Обратите внимание на значение prefix — это название ключа конфигурации, внутри которого лежит список сайтов. Аннотации приводят к автоматической инициализации объекта этого класса данными из файла application.yaml.
        *   Класс сервиса StatisticsServiceImpl помечен lombok-аннотацией `@RequiredArgsConstructor`, которая добавляет в него конструктор с аргументами, соответствующими неинициализированным final-полям класса. В этом классе только одно такое поле — sitesList, поэтому будет добавлен конструктор только с этим аргументом. При создании объекта класса StatisticsServiceImpl в конструктор будет передан объект класса SitesList, который, как было сказано выше, автоматически инициализируется на основе данных конфигурации.
*   В методе сервиса getStatistics происходит постепенная сборка объекта класса StatisticsResponse из данных о сайтах, а также некоторой случайной информации и двух заданных в начале метода массивов.
    *   Обратите внимание, что все классы, на основе которых сервисом собирается итоговый объект, размещены в папке dto и подпапке statistics. Аббревиатура DTO расшифровывается как Data Transfer Object, что в переводе с английского означает «Объект передачи данных». Все объекты запросов и ответов, которые вы будете использовать в приложении, а также объектов, из которых они будут построены, необходимо хранить в папке dto.
*   Придерживайтесь заданной нами структуры проекта: папок, интерфейсов и классов, а также принципов их именования. Это поможет вам быстрее создать итоговый проект и легко в нём ориентироваться, а нам — разобраться в написанном вами коде.
*   Установите на свой компьютер MySQL-сервер, если он ещё не установлен, и создайте в нём пустую базу данных search_engine. Для установки можете воспользоваться инструкциями. Создайте пользователя для подключения к базе данных. Это может быть пользователь root, который имеет доступ ко всем базам данных (создаётся при установке MySQL-сервера), а может быть отдельный пользователь, имеющий доступ только к созданной вами базе данных, на ваше усмотрение.
*   Подключите зависимости для работы с базой данных:

    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    ```

*   Создайте конфиг application.yaml в корне проекта и пропишите в нём в явном виде порт, по которому будет доступно веб-приложение, а также данные доступа к MySQL-серверу:

    ```yaml
    server:
      port: 8080
    spring:
      datasource:
        username: user
        password: pass
        url: jdbc:mysql://localhost:3306/search_engine?useSSL=false&requireSSL=false&allowPublicKeyRetrieval=true
      jpa:
        properties:
          hibernate:
            dialect: org.hibernate.dialect.MySQL8Dialect
        hibernate:
          ddl-auto: update
        show-sql: true
    ```

*   В проекте уже создан конфигурационный файл application.yaml в папке resources. Скопируйте его содержимое (перечень сайтов) в свой конфиг, а сам файл удалите из папки resources.
*   Запустите (или перезапустите) приложение и убедитесь, что оно запускается без ошибок, и главная страница по-прежнему открывается в браузere.

[К оглавлению](#toc)

<a name="этап-2-система-обхода-веб-страниц"></a>
# Этап 2. Система обхода веб-страниц

<a name="цель-0"></a>
### Цель

Реализовать многопоточное приложение, которое обходит все страницы сайта, начиная с главной.

<a name="что-нужно-сделать-0"></a>
### Что нужно сделать

*   На этом этапе — систему, которая будет по команде обходить веб-страницы сайтов и сохранять их содержимое в таблицу в базе данных.
*   Создайте в проекте папку model и в ней — классы, которые будут соответствовать таблицам site и page в базе данных. Структура таблиц описана в технической спецификации. Создайте их по правилам, которые вы изучали в модуле курса «Работа с MySQL в Java». В частности, не забудьте про аннотации `@Entity`, `@Id`, `@GeneratedValue`, `@ManyToOne` и `@JoinColumn`. Для enum-поля создайте отдельный Enum (его можно поместить в ту же папку model). Различные типы текстовых полей обозначайте аннотацией `@Column`:

    ```java
    @Column(columnDefinition = "ENUM('INDEXING', 'INDEXED')")
    @Column(columnDefinition = "VARCHAR(255)")
    @Column(columnDefinition = "TEXT")
    @Column(columnDefinition = "MEDIUMTEXT")
    ```

*   После создания классов для таблиц базы данных запустите приложение и убедитесь, что в базе данных появились соответствующие таблицы и что они имеют верную структуру.
*   Обратите внимание, что по полю path в таблице page должен быть установлен индекс, чтобы поиск по нему был быстрым, когда в нём много ссылок. Узнать об индексах можно в курсе Язык запросов SQL.
*   В качестве примера того, как создаются и используются классы для работы с базой данных, мы подготовили для вас специальный проект. Можете загрузить его по ссылке и ознакомиться с его структурой. Для запуска проекта прочитайте инструкции, приведённые в файле README.md, который лежит в корне.
*   Создайте в контроллере метод запуска индексации startIndexing в соответствии с технической спецификацией. В этом методе пропишите запуск сервиса индексации сайтов.
*   В сервисе индексации сайтов пропишите код, который будет брать из конфигурации приложения список сайтов и по каждому сайту:
    *   удалять все имеющиеся данные по этому сайту (записи из таблиц site и page);
    *   создавать в таблице site новую запись со статусом INDEXING;
    *   обходить все страницы, начиная с главной, добавлять их адреса, статусы и содержимое в базу данных в таблицу page;
    *   в процессе обхода постоянно обновлять дату и время в поле status_time таблицы site на текущее;
    *   по завершении обхода изменять статус (поле status) на INDEXED;
    *   если произошла ошибка и обход завершить не удалось, изменять статус на FAILED и вносить в поле last_error понятную информацию о произошедшей ошибке.
*   Для перехода по очередной ссылке должен создаваться новый поток при помощи Fork-Join. Этот поток будет получать содержимое страницы и перечень ссылок, которые есть на этой странице (значений атрибутов href HTML-тегов `<a>`), при помощи JSOUP.
*   **ОБРАТИТЕ ВНИМАНИЕ!** Задачу по обходу веб-страниц сайта вы уже решали в практической работе после модуля «Многопоточность». Рекомендуем использовать уже написанный вами код.
*   Обход каждого из сайтов, перечисленных в конфигурационном файле, должен запускаться в отдельном потоке.
*   Поскольку на страницах сайта могут находиться повторяющиеся ссылки, сервис должен проверять запросом к базе данных, заходил ли он по каждой очередной ссылке или нет.
*   Код ответа необходимо научиться определять самостоятельно, воспользовавшись документацией к библиотеке JSOUP.
*   После работы программы в таблице должны оказаться ссылки на все страницы заданных в конфиге сайтов без повторов.
*   Чтобы индексируемый сайт считал запросы от вашего приложения обычными посещениями пользователей, можно, например, обращаться к нему при помощи фейкового User-Agent и фейкового referrer так:

    ```java
    doc = Jsoup.connect("https://www.facebook.com/")
        .userAgent("Mozilla/5.0 (Windows; U; WindowsNT 5.1; en-US; rv1.8.1.6) Gecko/20070725 Firefox/2.0.0.6")
        .referrer("http://www.google.com")
        .get();
    ```

    Рекомендуется установить корректное значение User-Agent, например HeliontSearchBot (поисковый бот Heliont), где Heliont — пример названия вашего поискового движка, которое вы можете дать самостоятельно.
    Также рекомендуем вынести значения User-Agent и referer в конфигурацию вашего приложения и считывать их оттуда.
*   Некоторые сайты могут быть защищены от слишком частых запросов: их необходимо обходить аккуратно, с задержками в 0,5–5 секунд между запросами.
*   Реализуйте также функцию остановки обхода сайтов — команду API stopIndexing в соответствии с технической спецификацией. Она должна останавливать все потоки и записывать в базу данных для всех сайтов, страницы которых ещё не удалось обойти, состояние FAILED и текст ошибки «Индексация остановлена пользователем».

<a name="как-проверить-работу-программы"></a>
### Как проверить работу программы

Пропишите в конфигурации приложения хотя бы два сайта из следующего списка:

1.  http://www.playback.ru/
2.  https://volochek.life/
3.  http://radiomv.ru/
4.  https://ipfran.ru/
5.  https://dimonvideo.ru/
6.  https://nikoartgallery.com/
7.  https://et-cetera.ru/mobile/
8.  https://www.lutherancathedral.ru/
9.  https://dombulgakova.ru/
10. https://www.svetlovka.ru/

По итогам работы программы в базе данных должен оказаться список этих сайтов и их страниц. Например, для сайта http://www.playback.ru/ в таблицах должны быть данные следующего вида:

**site**

| id  | status  | status_time         | last_error | url                  | name         |
| --- | ------- | ------------------- | ---------- | -------------------- | ------------ |
| 1   | INDEXED | 2022-09-25 10:15:34 |            | http://www.playback.ru/ | PlayBack.Ru  |

**page**

| id  | site_id | path            | code | content*                                |
| --- | ------- | --------------- | ---- | --------------------------------------- |
| 1   | 1       | /               | 200  | `<!DOCTYPE html><html><head><title>Инт...` |
| 2   | 1       | /dostavka.html  | 200  | `<!DOCTYPE html><html><head><title>Инт...` |
| 3   | 1       | /pickup.html    | 200  | `<!DOCTYPE html><html><head><title>Инт...` |
| 4   | 1       | /payment.html   | 200  | `<!DOCTYPE html><html><head><title>Инт...` |
| ... | …       | ...             | ...  | ...                                     |

\*В поле content должны быть коды соответствующих страниц сайта.

[К оглавлению](#toc)

<a name="этап-3-система-индексации-веб-страниц"></a>
# Этап 3. Система индексации веб-страниц

<a name="описание"></a>
## Описание

Индексация — это процесс формирования поискового индекса по некоторому объёму информации. Поисковый индекс — это специальным образом организованная база данных (в нашем случае — база данных MySQL), позволяющая быстро и удобно осуществлять поиск по этой информации.

Скорость поиска по поисковому индексу в любых поисковых системах, как правило, занимает короткое время (обычно доли секунды) по сравнению с обычным поиском перебором по всему массиву информации. Вспомните разницу в скорости между поиском перебором в простом массиве и бинарным поиском в отсортированном.

Удобство хранения информации в индексе достигается за счёт правильно организованной структуры хранения — базы данных. В частности, по обычному тексту или набору текстов вы не сможете искать информацию с учётом морфологии русского языка и одновременно оценивать релевантность результатов, если у вас не будет специально организованного поискового индекса.

В рамках этого этапа вам будет необходимо подключить так называемый лемматизатор — библиотеку, которая позволяет получать леммы слов — их исходные формы. Например, для существительных — это слово в именительном падеже и единственном числе. Лемматизацию удобно использовать в поисковых движках, поскольку она позволяет искать нужную информацию с учётом морфологии. Например, на странице встречается слово «лошадей», а вы вводите поисковый запрос «лошадь». При простом поиске наличия слова в тексте данная страница не найдётся, а если все слова привести к «лошадь», то найдутся все страницы, на которых это слово присутствует в исходном или изменённом варианте.

Существует множество лемматизаторов. Мы будем использовать лемматизатор (ссылка приведена для справки, использовать коды из данного репозитория вам не нужно), который используется в широко используемом поисковом движке Apache Solr (он, в частности, используется в качестве поискового движка Википедии).

<a name="цель-1"></a>
### Цель

Реализовать систему индексации страниц сайта, которая позволит подсчитывать встречающиеся на страницах сайта слова (точнее, их леммы) и в дальнейшем по поисковому запросу определять наиболее релевантные страницы.

<a name="что-нужно-сделать-1"></a>
### Что нужно сделать

На втором этапе вы уже реализовали систему, которая умеет обходить страницы сайтов по ссылкам в многопоточном режиме. Теперь вам предстоит написать код, который будет извлекать из текстов страниц слова, преобразовывать их в леммы, считать количество вхождений каждой леммы в текст и сохранять эту информацию в базу данных.

*   Создайте классы для ещё двух таблиц базы данных (lemma и index) в соответствии с технической спецификацией.
*   Мы разработали и опубликовали для вас репозиторий с исходными кодами и сгенерированными JAR-библиотеками, предназначенными для лемматизации слов — получения из каждого слова его исходной формы. Ниже описаны шаги по подключению этих библиотек к вашему проекту.
*   Добавьте в файл pom.xml блок с указанием пути к созданному нами репозиторию (из него будут подгружаться зависимости):

    ```xml
    <repositories>
        <repository>
            <id>skillbox-gitlab</id>
            <url>https://gitlab.skillbox.ru/api/v4/projects/263574/packages/maven</url>
        </repository>
    </repositories>
    ```

*   Добавьте также в файл pom.xml в раздел с зависимостями все библиотеки из данного репозитория:

    ```xml
    <dependency>
        <groupId>org.apache.lucene.morphology</groupId>
        <artifactId>morph</artifactId>
        <version>1.5</version>
    </dependency>
    <dependency>
        <groupId>org.apache.lucene.analysis</groupId>
        <artifactId>morphology</artifactId>
        <version>1.5</version>
    </dependency>
    <dependency>
        <groupId>org.apache.lucene.morphology</groupId>
        <artifactId>dictionary-reader</artifactId>
        <version>1.5</version>
    </dependency>
    <dependency>
        <groupId>org.apache.lucene.morphology</groupId>
        <artifactId>english</artifactId>
        <version>1.5</version>
    </dependency>
    <dependency>
        <groupId>org.apache.lucene.morphology</groupId>
        <artifactId>russian</artifactId>
        <version>1.5</version>
    </dependency>
    ```

*   Теперь вам необходимо указать токен для доступа к данному Maven-репозиторию, поскольку GitLab запрещает публичный доступ к библиотекам. Для указания токена найдите или создайте файл settings.xml.
*   В Windows он располагается в директории `C:/Users/<Имя вашего пользователя>/.m2`
*   В Linux — в директории `/home/<Имя вашего пользователя>/.m2`
*   В macOs — по адресу `/Users/<Имя вашего пользователя>/.m2`

    Если файла settings.xml нет, создайте его и вставьте в него код:

    ```xml
    <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd">
        <servers>
            <server>
                <id>skillbox-gitlab</id>
                <configuration>
                    <httpHeaders>
                        <property>
                            <name>Private-Token</name>
                            <value>wtb5axJDFX9Vm_W1Lexg</value>
                        </property>
                    </httpHeaders>
                </configuration>
            </server>
        </servers>
    </settings>
    ```

    Если файл уже есть, но в нём нет блока `<servers>`, то добавьте в него только этот блок. Если этот блок в файле есть, добавьте внутрь него блок `<server>` из фрагмента кода, приведённого выше.

    В блоке `<value>` находится уникальный токен доступа. Если у вас возникнет «401 Ошибка Авторизации» при попытке получения зависимостей, возьмите актуальный токен доступа из документа по ссылке. Если он не подойдёт, запросите у куратора актуальный токен доступа, пришлите куратору файл settings.xml и логи обновления зависимостей.

    Обязательно почистите кэш maven. Самый надёжный способ — удалить директорию:
    *   Windows: `C:\Users\<user_name>\.m2\repository`
    *   macOs: `/Users/<user_name>/.m2/repository`
    *   Linux: `/home/<user_name>/.m2/repository`

    `<user_name>` — имя пользователя, под которым вы работаете.

    После этого снова попробуйте обновить данный из pom.xml.

    Затем обновите зависимости в проекте при помощи `<Ctrl+Shift+O>` или `<⌘⇧I>`:

    Пример проекта с подключенными библиотеками, настроенным pom.xml и примером settings.xml — в отдельном репозитории.
*   **Внимание!** Если сервер для загрузки библиотек морфологии не отвечает, вы можете добавить зависимости в проект вручную. Для этого скачайте библиотеки.
*   После подключения зависимостей создайте отдельный класс с методом main, чтобы проверить, как работает лемматизация. Код лемматизатора работает следующим образом:

    ```java
    LuceneMorphology luceneMorph = new RussianLuceneMorphology();
    List<String> wordBaseForms = luceneMorph.getNormalForms("леса");
    wordBaseForms.forEach(System.out::println);
    ```

    Данный код выведет следующие строки (две возможные исходные формы слова «леса»):

    ```
    лес
    леса
    ```

*   Создайте класс с методом, который будет принимать в качестве параметра текст и возвращать перечень лемм для каждого слова в этом тексте (за исключением междометий, союзов, предлогов и частиц — см. ниже) и количество упоминаний каждой такой леммы в переданном тексте. Ниже описаны детали реализации данного метода.

    Пример текста на входе:

    > Повторное появление леопарда в Осетии позволяет предположить, что леопард постоянно обитает в некоторых районах Северного Кавказа.

    Ожидаемый результат:

    ```
    повторный — 1
    появление — 1
    постоянно — 1
    позволять — 1
    предположить — 1
    северный — 1
    район — 1
    кавказ — 1
    осетия — 1
    леопард — 2
    обитать — 1
    ```

*   **ОБРАТИТЕ ВНИМАНИЕ!** Разделение текстов на слова вы уже реализовывали в одном из заданий к модулю «Строки» курса «Java-разработчик c нуля». Рекомендуем использовать в этом проекте уже написанный вами ранее код.
*   Метод должен возвращать `HashMap<String, Integer>`, в котором ключами будут леммы, а значениями — их количества в переданном тексте.
*   Передаваемые в метод тексты необходимо очищать от служебных частей речи. Часть речи можно определить так:

    ```java
    LuceneMorphology luceneMorph = new RussianLuceneMorphology();
    List<String> wordBaseForms = luceneMorph.getMorphInfo("или");
    wordBaseForms.forEach(System.out::println);
    ```

    Такой код выдаст следующую информацию:

    ```
    или|n СОЮЗ
    ```

    В данном случае «СОЮЗ» означает, что слово является союзом. Другие примеры:

    ```
    и|o МЕЖД
    копал|A С мр,ед,им
    копать|a Г дст,прш,мр,ед
    хитро|j Н
    хитрый|Y КР_ПРИЛ ср,ед,од,но
    синий|Y П мр,ед,вн,но
    ```

*   Если с реализацией кода возникают сложности, посмотрите наш пример такого кода.
*   Также можете посмотреть пример реализации приложения с использованием данных классов и библиотек в проекте, который мы вам рекомендовали ранее. Можете загрузить его к себе на компьютер и собрать в соответствии с инструкциями, приведёнными в файле README.md (файл лежит в корне проекта).
*   В этом же классе реализуйте метод, который будет очищать код веб-страниц от HTML-тегов.
*   Реализуйте функцию индексации отдельной веб-страницы. Для этого сначала реализуйте метод контроллера для команды API indexPage в соответствии с технической спецификацией.
*   Напишите код, который будет получать HTML-код переданной веб-страницы, сохранять его в базу данных в таблицу page, преобразовывать в набор лемм и их количеств, а затем сохранять эту информацию в таблицы lemma и index базы данных следующим образом:
    *   Леммы должны добавляться в таблицу lemma. Если леммы в таблице ещё нет, она должна туда добавляться со значением frequency, равным 1. Если же лемма в таблице уже есть, число frequency необходимо увеличить на 1. Число frequency у каждой леммы в итоге должно соответствовать количеству страниц, на которых эта лемма встречается хотя бы один раз.
    *   Связки лемм и страниц должны добавляться в таблицу index. Для каждой пары «лемма-страница» в этой таблице должна создаваться одна запись с указанием количества данной леммы на страницы в поле rank.
*   Проверьте работу индексации на отдельной странице, указав путь к ней в веб-интерфейсе вашего приложения и запустив её индексацию. Не забудьте, что при добавлении страницы в базу данных она должна привязываться к записи в таблице site, которая либо уже должна там находиться, либо должна быть создана на основе одного из пунктов списка сайтов в конфигурации вашего приложения.
*   В случае попытки индексации страницы с какого-то другого сайта команда API должна выдавать ошибку в соответствии с технической спецификацией. Убедитесь в этом в веб-интерфейсе вашего приложения.
*   В случае, если переданная страница уже была проиндексирована, перед её индексацией необходимо удалить всю информацию о ней из таблиц page, lemma и index.
*   Допишите код обхода веб-страниц, который вы создавали на втором этапе таким образом, чтобы каждая полученная веб-страница преобразовывалась в набор лемм и их количеств, и эта информация также сохранялась в таблицы lemma и index базы данных по описанному выше алгоритму.
*   Коды страниц, при получении которых HTTP-ответ был ошибочным (с кодами 4xx или 5xx), индексировать не нужно.
*   Запустите индексацию пары сайтов из списка выше и убедитесь, что всё работает.
*   Перепишите также метод API statistics. Он должен рассчитывать статистику и возвращать её в формате, описанном в технической спецификации. Формировать статистику рекомендуем, используя классы, уже созданные в пакете dto.statistics. Статистика должна отображаться на главной странице сервиса.

<a name="как-проверить-работу-программы-0"></a>
### Как проверить работу программы

С помощью веб-интерфейса запустите и остановите индексацию сайтов (см. список в этапе 2) и убедитесь в том, что после индексации хотя бы пары сайтов (из списка выше, см. этап 2) данные в базе, в том числе в таблицах lemma и index, выглядят правдоподобно, а сама индексация при этом завершается без ошибок и для всех страниц с неошибочными HTTP-кодами (не 4xx и не 5xx) есть записи в таблице index. Также на главной странице вашего сервиса должна отображаться правдоподобная статистика.

Обновите или добавьте отдельные страницы на проиндексированных сайтах и убедитесь, что в базе произошли соответствующие изменения. К примеру, можно проиндексировать какой-то сайт, удалить из базы данные по одной из его страниц (из таблиц page и index), запустить добавление этой страницы через веб-интерфейс и убедиться, что страница снова появилась в таблице page и для неё появились записи в таблице index.

Проверить корректность индексации можно только после реализации системы поиска (см. следующий этап).

[К оглавлению](#toc)

<a name="этап-4-система-поиска"></a>
# Этап 4. Система поиска

<a name="цель-2"></a>
### Цель

Реализовать систему поиска информации с использованием созданного поискового индекса.

<a name="что-нужно-сделать-2"></a>
### Что нужно сделать

Необходимо дописать в программе код, который будет по поисковому запросу (строке текста) выдавать результаты поиска в виде списка объектов с их свойствами.

*   Создайте метод для команды API search в соответствии с технической спецификацией. Метод должен выполнять следующий алгоритм:
*   Разбивать поисковый запрос на отдельные слова и формировать из этих слов список уникальных лемм, исключая междометия, союзы, предлоги и частицы. Используйте для этого код, который вы уже писали в предыдущем этапе.
*   Исключать из полученного списка леммы, которые встречаются на слишком большом количестве страниц. Поэкспериментируйте и определите этот процент самостоятельно.
*   Сортировать леммы в порядке увеличения частоты встречаемости (по возрастанию значения поля frequency) — от самых редких до самых частых.
*   По первой, самой редкой лемме из списка, находить все страницы, на которых она встречается. Далее искать соответствия следующей леммы из этого списка страниц, а затем повторять операцию по каждой следующей леmме. Список страниц при этом на каждой итерации должен уменьшаться.
*   Если в итоге не осталось ни одной страницы, то выводить пустой список.
*   Если страницы найдены, рассчитывать по каждой из них релевантность (и выводить её потом, см. ниже) и возвращать.
*   Для каждой страницы рассчитывать абсолютную релевантность — сумму всех rank всех найденных на странице лемм (из таблицы index), которая делится на максимальное значение этой абсолютной релевантности для всех найденных страниц. Пример расчёта:

| Страница | Rank слова «лошадь» | Rank слова «бегает» | Абсолютная релевантность | Относительная релевантность |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 4,2 | 3,1 | 7,3 | 0,7 |
| 2 | 1,0 | 1,5 | 2,5 | 0,24 |
| 3 | 9,9 | 0,4 | 10,3 | 1 |

Пример расчёта абсолютной релевантности для первой страницы:

`Rabs = 4,2 + 3,1 = 7,3`

Относительную релевантность можно получить делением абсолютной релевантности для конкретной страницы на максимальную абсолютную релевантность среди всех страниц данной поисковой выдачи:

`Rrel = 7,3 / 10,3 = 0,7087`

*   Сортировать страницы по убыванию релевантности (от большей к меньшей) и выдавать в виде списка объектов со следующими полями:
    *   **uri** — путь к странице вида /path/to/page/6784;
    *   **title** — заголовок страницы;
    *   **snippet** — фрагмент текста, в котором найдены совпадения (см. ниже);
    *   **relevance** — релевантность страницы (см. выше формулу расчёта).
*   Сниппеты — фрагменты текстов, в которых найдены совпадения, для всех страниц должны быть примерно одинаковой длины — такие, чтобы на странице с результатами поиска они занимали примерно три строки. В них необходимо выделять жирным совпадения с исходным поисковым запросом. Выделение должно происходить в формате HTML при помощи тега `<b>`. Алгоритм получения сниппета из веб-страницы реализуйте самостоятельно.
*   Обратите внимание, что метод поиска должен учитывать, по каким сайтам происходит этот поиск — по всем или по тому, который выбран в веб-интерфейсе в выпадающем списке.

<a name="как-проверить-работу-программы-1"></a>
### Как проверить работу программы

Проиндексируйте несколько сайтов из списка выше (см. этап 2) и запустите поиск по фразам, которые встречаются на определённых страницах каждого сайта и не встречаются на других сайтах, а затем сравните результат с ожидаемым.

При запросе фразы, существующей на странице сайта, эта страница должна быть найдена и должна иметь высокую релевантность, а при запросе несуществующей на сайте фразы должен быть выдан пустой список.

[К оглавлению](#toc)

<a name="этап-5-публикация-проекта-на-github"></a>
# Этап 5. Публикация проекта на GitHub

<a name="цель-3"></a>
### Цель

Разместить разработанный проект в публичном доступе для итоговой презентации кураторам и демонстрации своим потенциальным работодателям.

<a name="что-нужно-сделать-3"></a>
### Что нужно сделать

*   Разместите исходные коды вашего приложения в публичном доступе в своём GitHub. Создайте в корне репозитория файл README.md, в котором:
    *   опишите проект;
    *   стэк используемых технологий;
    *   инструкцию по локальному запуску проекта — последовательность команд и действий.
*   В написании красивого и понятного файла README.md вам поможет наше руководство «Как написать красивый и информативный README.md».

[К оглавлению](#toc)
