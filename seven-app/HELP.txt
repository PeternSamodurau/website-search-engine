Подробный план работ

Шаг 1: Добавление зависимостей
•Добавим зависимость spring-boot-starter-security.

Шаг 2: Модификация сущности User
•Создадим перечисление RoleType с двумя значениями: ROLE_USER, ROLE_MANAGER.•Добавим в класс User два новых поля:•password (тип String) для хранения хешированного пароля.•roles (тип Set<RoleType>) для хранения ролей пользователя, как рекомендовано в ТЗ.•Реализуем в классе User интерфейс UserDetails от Spring Security. Это свяжет нашу модель пользователя с системой безопасности.Шаг 3: Создание сервиса для загрузки пользователей•Создадим новый сервис, например, MongoUserDetailsService, который будет реализовывать интерфейс ReactiveUserDetailsService.•В этом сервисе будет один метод findByUsername(String username), который ищет пользователя в MongoDB по его имени и возвращает Mono<UserDetails>.Шаг 4: Создание основной конфигурации безопасности•Создадим конфигурационный класс SecurityConfig.•Включим поддержку безопасности для WebFlux с помощью аннотации @EnableWebFluxSecurity.•Включим поддержку безопасности на уровне методов с помощью @EnableReactiveMethodSecurity.•Определим бин PasswordEncoder (используя BCryptPasswordEncoder).•Создадим главный бин SecurityWebFilterChain, в котором настроим:•Отключение CSRF (стандартная практика для REST API).•Включение Basic Authentication.•Базовые правила доступа к эндпоинтам.Шаг 5: Защита методов контроллера UserController•Перейдем к контроллеру, отвечающему за пользователей.•Добавим аннотацию @PreAuthorize("hasAnyRole('USER', 'MANAGER')") ко всем методам, связанным с получением, обновлением и удалением пользователей.Шаг 6: Защита методов контроллера TaskController•Перейдем к контроллеру, отвечающему за задачи.•Добавим аннотацию @PreAuthorize("hasAnyRole('USER', 'MANAGER')") к методам получения задач и добавления наблюдателя.•Добавим аннотацию @PreAuthorize("hasRole('MANAGER')") к методам создания, обновления и удаления задач.Шаг 7: Интеграция UserDetails в контроллеры•Обновим методы контроллеров, чтобы они получали информацию о текущем пользователе не из параметров запроса, а напрямую из контекста безопасности с помощью аннотации @AuthenticationPrincipal.