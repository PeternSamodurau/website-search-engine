### Приложение «Учёт студентов» 

#### Этап 1: Настройка проекта и создание основной сущности
Подготовка основы проекта и определение модели данных студента.

*   **`build.gradle`**: Добавление зависимостей:
    *   `spring-boot-starter`
    *   `spring-shell-starter`
    *   `lombok`
    *   `jakarta.annotation:jakarta.annotation-api` (для поддержки `@PostConstruct` в Java 11+)
*   **Автоматическое логирование**: Все логи приложения (информация о запуске, ошибки и т.д.) записываются в файл `log.txt`, который создается в корневой папке проекта. 
*   **`Student.java`**: Создание класса-сущности `Student` с полями `id` (UUID), `firstName` (String), `lastName` (String), `age` (int). 
        Использование аннотаций Lombok (`@Data`, `@AllArgsConstructor`) для автоматической генерации `getters`, `setters`, `toString` и конструкторов.

#### Этап 2: Создание слоя хранения данных (Repository)
Создание компонента для хранения студентов в памяти.

*   **`StudentRepository.java`**: Создание интерфейса, описывающего операции с хранилищем: `findAll()`, `save()`, `deleteById()`, `deleteAll()`.
*   **`InMemoryStudentRepository.java`**: Создание реализации интерфейса. Использование `java.util.Map<UUID, Student>` для хранения данных.

#### Этап 3: Создание слоя бизнес-логики (Service)
Создание центрального сервиса для управления логикой.

*   **`StudentServicePublisher.java`**: Создание интерфейса для сервиса: `getAllStudents()`, `addStudent()`, `deleteStudent()`, `clearStudents()`.
*   **`StudentServicePublisherImpl.java`**: Создание реализации сервиса. Использование `StudentRepository` для доступа к данным.

#### Этап 5: Создание пользовательского интерфейса (Spring Shell)
Реализация возможности управлять приложением через консольные команды.

*   **`StudentCommands.java`**: Создание `@ShellComponent` с методами, помеченными `@ShellMethod`:
    *   `list`: для вывода всех студентов.
    *   `add`: для добавления нового студента. Принимает `firstName`, `lastName`, `age`.
    *   `delete`: для удаления студента по `id`.
    *   `purge`: для полной очистки списка студентов. (Переименована из `clear` во избежание конфликта со встроенной командой Spring Shell).

#### Этап 6: Настройка начальной загрузки данных
Добавление отключаемой функции создания студентов при старте приложения с использованием профилей Spring.

*   **`application.properties`**: Добавление свойства `spring.profiles.active=init` для активации профиля инициализации. Также добавлено свойство `app.init.students-file-path` для указания пути к файлу с данными.
*   **`StudentInitializer.java`**: Создание компонента, помеченного аннотацией `@Profile("init")`. Он будет создан и активирован только в том случае, если активен профиль `init`.
       Логика инициализации студентов запускается в методе, помеченном аннотацией `@PostConstruct`, который выполняется сразу после создания компонента.
       Компонент считывает студентов из файла, указанного в `app.init.students-file-path`.

#### Этап 7: Контейнеризация и документирование
Упаковка приложения в Docker-контейнер и написание инструкции по его использованию.

*   **`Dockerfile`**: Создание файла с инструкциями для сборки Docker-образа.
*   **`README.md`**: Написание актуальной документации.

---

### Как это работает

Приложение запустится, и если активен профиль `init`, оно загрузит студентов из файла и будет готово к работе. 

1.  **Точка входа (`SkillboxSecondTaskApplication.java`)**:
    *   Класс помечен аннотацией `@SpringBootApplication`. Это главный "выключатель", который говорит Spring: 
        "Это основная точка конфигурации, начни сканировать пакеты, найди компоненты и настрой всё автоматически". 
        Она включает в себя `@Configuration`, `@ComponentScan` и `@EnableAutoConfiguration`.

2.  **Компоненты (наши классы)**:
    *   Spring сканирует проект и находит классы, помеченные специальными аннотациями (`@Component`, `@Service`, `@Repository`, `@ShellComponent`). 
        Он создает по одному экземпляру каждого такого класса (это "бин" - bean) и помещает в свой "контейнер" (контекст).
    *   `@Repository` (`InMemoryStudentRepository`): Компонент для работы с данными.
    *   `@Service` (`StudentServicePublisherImpl`): Компонент для бизнес-логики.
    *   `@ShellComponent` (`StudentCommands`): Особый компонент, который делает свои методы доступными как команды в консоли.
    *   `@Component` (`StudentInitializer`): Общая аннотация для любого управляемого Spring компонента.

3.  **Внедрение зависимостей (DI) с помощью `@RequiredArgsConstructor`**:
    *   Вместо того чтобы вручную создавать объекты (`new StudentServicePublisherImpl()`),  
        помечаем наши классы аннотацией `@RequiredArgsConstructor` из Lombok.
    *   Эта аннотация автоматически создает конструктор, который принимает все `final` поля класса.
    *   Когда Spring создает бин (например, `StudentCommands`), он видит, что конструктору нужен `StudentServicePublisher`.
        Spring находит в своем контейнере уже созданный бин `StudentServicePublisherImpl` и автоматически "подставляет" его.
        Этот процесс и называется DI **внедрением зависимостей через конструктор**.

4.  **Интерфейс командной строки (`StudentCommands.java`)**:
    *   Аннотация `@ShellComponent` регистрирует класс как источник команд.
    *   Аннотация `@ShellMethod(key = "list", ...)` делает публичный метод доступным в консоли по ключу `list`. 

5.  **Инициализация приложения: `@Profile` и `@PostConstruct`**:
    *   `@Profile("init")` на классе `StudentInitializer` — это условие. 
         Spring создаст бин этого класса, **только если** при запуске активен профиль `init` (через `spring.profiles.active=init` в `application.properties`).
    *   `@PostConstruct` на методе `initialize()` — эта аннотация отработает после создания обьекта класса. 
         Как только Spring полностью создал бин `StudentInitializer` и внедрил в него все зависимости, он вызывает этот метод. 
         Это загрузит начальные данные.

6.  **Cлушатель команд (Spring Shell)**

      Не создаем (`ConsoleInputHandler`) и вручную  не запускаем его в отдельном потоке, 
      в этом проекте данная задача полностью делегирована фреймворку **Spring Shell**. 
 
      Вот как это работает на уровне аннотаций:

    1.  **`@ShellComponent` на классе `StudentCommands`**:
    *   Она сообщает Spring Shell, что данный класс — это не просто обычный бин, а **поставщик консольных команд**.
    *   При старте приложения Spring Shell сканирует все бины, помеченные этой аннотацией, и ищет в них методы, которые можно превратить в команды.

    2.  **`@ShellMethod` на методах (`list`, `add`, `delete`, `purge`)**:
    *   Эта аннотация размещается над публичными методами внутри `@ShellComponent`. 
        Она говорит: "Этот метод является исполняемой командой".
    *   Атрибут `key` (например, `@ShellMethod(key = "list", ...)` ) задает имя, 
        по которому команда будет вызываться из консоли.
    *   Spring Shell автоматически анализирует параметры метода (например, `String firstName, String lastName, int age` в методе `add`) 
        и понимает, как преобразовать строку, введенную пользователем в консоли, 
        в аргументы для вызова этого метода.

    3.  **Внедрение зависимостей (`@RequiredArgsConstructor`)**:
    *   Класс `StudentCommands` не содержит бизнес-логики. 
        Он принимает команды и делегирует их выполнение сервисному слою.
    *   С помощью конструктора и аннотации Lombok `@RequiredArgsConstructor` в него внедряется зависимость `StudentServicePublisher`.
    *   Когда из консоли вызывается команда (например, `add Иван Иванов 25`), 
        Spring Shell вызывает соответствующий метод (`add(...)`), который, в свою очередь, 
        вызывает метод сервиса (`studentService.addStudent(...)`), передавая ему полученные данные.

Таким образом, вся работа по созданию консольного интерфейса, прослушиванию ввода, разбору команд и их аргументов выполняется самим фреймворком.

Таким образом, Spring Boot берет на себя всю рутинную работу по созданию, настройке и связыванию объектов.

---

### Запуск через docker-compose.yml

Файл `docker-compose.yml` позволяет удобно управлять жизненным циклом приложения в Docker.

**Шаг 1: Сборка JAR-файла**

Перед запуском через Docker Compose необходимо убедиться, что собран актуальный `.jar`-файл приложения. 
Для этого выполните в терминале в корне проекта:

```sh
./gradlew bootJar
```

**Шаг 2: Запуск в интерактивном режиме**

Приложение требует интерактивного взаимодействия. Для этого используется команда `docker-compose run`. 
Выполните в терминале:

```sh
docker-compose run --rm student-app
```

*   `docker-compose run`: Запускает один экземпляр сервиса и появится терминал.
*   `--rm`: Флаг, который автоматически удалит контейнер после завершения сеанса. 
*   `student-app`: Имя сервиса, которое мы определили в `docker-compose.yml`.

После выполнения команды вы увидите логи запуска Spring, а затем — приглашение `shell:>` для ввода команд.
