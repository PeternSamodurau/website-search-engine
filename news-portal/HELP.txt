Внедрение Spring Security

Этап 1: Подготовка и настройка зависимостей

•Что делаем:
Добавляем в файл build.gradle зависимости spring-boot-starter-security и spring-boot-starter-aop.

Этап 2: Модификация модели данных и сервиса
•Что делаем:
1.Добавляем в сущность User поля password (тип String) и roles (тип String).
2.Реализуем в классе User интерфейс UserDetails от Spring Security.
  Это потребует реализовать методы getAuthorities(), getPassword(), getUsername() и т.д.
3.Создаем новый сервис UserDetailsServiceImpl, который реализует интерфейс UserDetailsService. Его задача — по имени пользователя (username) загружать из репозитория (UserRepository) полную информацию о нем.•Почему: Мы готовим нашу систему к работе с Spring Security.•Поля password и roles — это основа для аутентификации (проверки пароля) и авторизации (проверки ролей).•Реализация UserDetails превращает нашу сущность User в объект, который Spring Security "понимает" и может использовать в своем контексте безопасности.•UserDetailsService — это обязательный "мост" между Spring Security и нашей базой данных пользователей.Этап 3: Базовая конфигурация безопасности•Что делаем:1.Создаем класс SecurityConfig с аннотациями @Configuration и @EnableWebSecurity.2.Внутри него создаем бин PasswordEncoder (например, BCryptPasswordEncoder).3.Создаем главный бин SecurityFilterChain, в котором настраиваем:•Отключение CSRF (т.к. у нас REST API).•Включение Basic-аутентификации (httpBasic()).•Первичные, общие правила доступа к эндпоинтам (например, разрешить доступ ко всем эндпоинтам для аутентифицированных пользователей).•Почему: На этом этапе мы включаем саму защиту. PasswordEncoder критически важен для безопасного хранения паролей в виде хешей, а не в открытом виде. SecurityFilterChain — это центральное место, где мы определяем, как именно будет защищено наше приложение.Этап 4: Обновление данных и тестирование•Что делаем:1.Модифицируем файл data/news.json (или ваш механизм начальной загрузки данных).2.Для существующих пользователей добавляем роли (ROLE_ADMIN, ROLE_USER, ROLE_MODERATOR) и хешированные пароли.•Почему: Без пользователей с ролями и паролями мы не сможем протестировать нашу систему безопасности. Приложение просто не позволит никому войти.Этап 5: Реализация проверки прав через AOP (для UserController)•Что делаем:1.Создаем аспект (класс с аннотацией @Aspect).2.Внутри него описываем @Before advice, который будет срабатывать перед вызовом методов getUserById, updateUser и deleteUser в UserController.3.В логике advice'а получаем текущего аутентифицированного пользователя из SecurityContextHolder и ID пользователя из аргументов метода.4.Реализуем логику из ТЗ: если у пользователя роль USER, проверяем, совпадает ли его ID с запрашиваемым. Если нет — выбрасываем исключение AccessDeniedException.•Почему: Это прямое выполнение одного из ключевых и самых сложных требований ТЗ. AOP позволяет вынести логику проверки прав из самого контроллера, делая код чище.Этап 6: Детальная настройка прав доступа и рефакторинг контроллеров•Что делаем:1.UserController: Добавляем аннотацию @PreAuthorize("hasRole('ADMIN')") на метод получения всех пользователей.2.CategoryController: Расставляем аннотации @PreAuthorize на методы в соответствии с ТЗ (например, @PreAuthorize("hasAnyRole('ADMIN', 'MODERATOR')") для удаления).3.NewsController и CommentController:•Убираем userId из всех DTO и параметров методов.•В методы контроллера добавляем параметр (@AuthenticationPrincipal UserDetails userDetails).•Из userDetails получаем ID или имя текущего пользователя и передаем его в сервисный слой.•Реализуем сложную логику прав (например, "удалить комментарий может автор или модератор") с помощью аннотаций @PreAuthorize и выражений на языке SpEL.•Почему: Это финальный этап, на котором мы реализуем все оставшиеся правила авторизации. Использование @PreAuthorize — это стандартный, мощный и декларативный способ защиты методов в Spring Security. Рефакторинг контроллеров для получения пользователя из контекста безопасности делает API более надежным и правильным с точки зрения архитектуры.