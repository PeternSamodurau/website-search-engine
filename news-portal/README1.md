# Практическая работа: Создание REST API для новостного сервиса

### Этап 1: Настройка проекта и окружения

*   **`build.gradle`**: 
    *   `Spring Web`: для **разработки REST API с использованием Spring MVC**.
    *   `Spring Data JPA`: для работы с базой данных.
    *   `Validation`: для валидации входящих запросов.
    *   `Spring Boot Starter AOP`: для реализации аспектно-ориентированной логики.
    *   `springdoc-openapi-starter-webmvc-ui`: для **автоматической генерации интерактивной документации и UI для тестирования API (Swagger UI)**.
    *   `PostgreSQL Driver`: драйвер для подключения к нашей базе данных.
    *   `Lombok`: для сокращения шаблонного кода.
    *   `MapStruct`: для автоматического маппинга между DTO и сущностями.

*   **Инициализация данных**: Для первоначального наполнения базы данных мы будем использовать публичное API **`newsapi.org`**.
      Будет создан специальный сервис, который при старте приложения (с профилем `init`) будет запрашивать новости и сохранять их в нашу базу.

*   **`Dockerfile` и `docker-compose.yml`**: Создаем файлы для запуска приложения и базы данных PostgreSQL в Docker-контейнерах.

*   **`application.properties`**: Настраиваем подключение к базе данных, указывая URL, имя пользователя и пароль из `docker-compose.yml`.

---

### Этап 2: Слой данных (Data Layer)
  
* **Сущности (Entities)**: В пакете `model` создаем классы-сущности `User`, `Category`, `News`, `Comment`. Используем аннотации JPA (`@Entity`, `@Table`, `@Id`) и настраиваем связи между ними (`@ManyToOne`, `@OneToMany`).
*   **Репозитории**: Для каждой сущности создаем свой интерфейс-репозиторий (`UserRepository`, `NewsRepository` и т.д.), унаследовав его от `JpaRepository`. Для `NewsRepository` также добавляем наследование от `JpaSpecificationExecutor` для будущей фильтрации.
*   **`resources/schema.sql`**: Создаем SQL-скрипт с командами `CREATE TABLE` для всех наших сущностей. Он будет автоматически выполняться при старте и создавать структуру таблиц в БД.

---

### Этап 3: Слой представления (View Layer)

Этот слой — «входные ворота» в наше API. Он отвечает за прием HTTP-запросов и отправку ответов.

*   **DTO и Маппинг**: Для каждой сущности проектируем DTO и с помощью `MapStruct` создаем мапперы для преобразования `Entity <-> DTO`.
    *   `NewsMapper` должен уметь создавать DTO с полем `commentsCount` для списков и DTO с полным списком комментариев для одиночной новости.
*   **Контроллеры**: Создаем классы с аннотацией `@RestController` (`UserController`, `NewsController` и т.д.). Их методы будут принимать запросы, вызывать сервисы и возвращать клиенту DTO.
*   **Пагинация и Фильтрация**: В `NewsController` реализуем постраничный вывод списка новостей и принимаем параметры для фильтрации по автору и категории.
*   **Валидация**: В DTO, приходящих в запросах, используем аннотации валидации (`@NotBlank`, `@Size` и т.д.), а в методах контроллеров — аннотацию `@Valid`.

---

### Этап 4: Слой бизнес-логики (Business Logic Layer)

«Сердце» нашего приложения, где реализуется вся основная логика.

*   **Сервисы**: Для каждой основной сущности создаем свой класс-сервис (`UserService`, `NewsService` и т.д.), куда внедряем репозитории.
*   **Фильтрация (Specification)**: В `NewsService` создаем метод, который принимает параметры фильтрации и с помощью `Specification` строит динамический запрос к БД.
*   **Контроль доступа (AOP)**:
    1.  Создаем аннотацию `@CheckEntityOwnership`.
    2.  Создаем Аспект (`@Aspect`), который будет выполняться `@Before` методов, помеченных этой аннотацией.
    3.  В аспекте реализуем логику проверки, что текущий пользователь является автором сущности. Если нет — выбрасываем исключение.
    4.  Помечаем аннотацией методы обновления и удаления в `NewsService` и `CommentService`.
*   **Обработка ошибок**: Создаем класс с аннотацией `@RestControllerAdvice` для глобальной обработки исключений. В нем перехватываем ошибки валидации, доступа, ненайденных сущностей и возвращаем клиенту понятный JSON с корректным HTTP-статусом.