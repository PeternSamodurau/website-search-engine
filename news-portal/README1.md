# Практическая работа: Создание REST API для новостного сервиса

### Этап 1: Настройка проекта и окружения

*   **`build.gradle`**: 
    *   `Spring Web`: для **разработки REST API с использованием Spring MVC**.
    *   `Spring Data JPA`: для работы с базой данных.
    *   `Validation`: для валидации входящих запросов.
    *   `Spring Boot Starter AOP`: для реализации аспектно-ориентированной логики.
    *   `springdoc-openapi-starter-webmvc-ui`: для **автоматической генерации интерактивной документации и UI для тестирования API (Swagger UI)**.
    *   `PostgreSQL Driver`: драйвер для подключения к нашей базе данных.
    *   `Lombok`: для сокращения шаблонного кода.
    *   `MapStruct`: для автоматического маппинга между DTO и сущностями.

*   **Инициализация данных**: Для первоначального наполнения базы данных мы будем использовать публичное API **`newsapi.org`**.
      Будет создан специальный сервис, который при старте приложения (с профилем `init`) будет запрашивать новости и сохранять их в нашу базу.

*   **`Dockerfile` и `docker-compose.yml`**: Создаем файлы для запуска приложения и базы данных PostgreSQL в Docker-контейнерах.

*   **`application.properties`**: Настраиваем подключение к базе данных, указывая URL, имя пользователя и пароль из `docker-compose.yml`.

---

### Этап 2: Слой данных (Data Layer)
  
* **Сущности (Entities)**: В пакете `model` создаем классы-сущности `User`, `Category`, `News`, `Comment`. Используем аннотации JPA (`@Entity`, `@Table`, `@Id`) и настраиваем связи между ними (`@ManyToOne`, `@OneToMany`).
  
    1. User (Пользователь)

*   **Связи:**
    *   **One-to-Many** с `News`: Один пользователь может быть автором множества новостей.
    *   **One-to-Many** с `Comment`: Один пользователь может быть автором множества комментариев.

*   **Поля сущности:**
    *   `id` (`Long`): Уникальный идентификатор.
    *   `username` (`String`): Имя пользователя (будем брать из `author` в `newsapi.org`).
    *   `email` (`String`): Электронная почта.
    *   `password` (`String`): Пароль (необходим для `Spring Security`).

*   **Поля для связей:**
    *   `newsList` (`List<News>`): Список новостей, написанных этим пользователем.
    *   `comments` (`List<Comment>`): Список комментариев, оставленных этим пользователем.

---

### 2. Category (Категория)

*   **Связи:**
    *   **One-to-Many** с `News`: В одной категории может быть много новостей.

*   **Поля сущности:**
    *   `id` (`Long`): Уникальный идентификатор.
    *   `name` (`String`): Название категории .

*   **Поля для связей:**
    *   `newsList` (`List<News>`): Список новостей, принадлежащих этой категории.

---

### 3. News (Новость)

*   **Связи:**
    *   **Many-to-One** с `User`: Множество новостей могут принадлежать одному автору.
    *   **Many-to-One** с `Category`: Множество новостей могут принадлежать одной категории.
    *   **One-to-Many** с `Comment`: Одна новость может иметь множество комментариев.

*   **Поля сущности (из `newsapi.org`):**
    *   `id` (`Long`): Уникальный идентификатор.
    *   `title` (`String`): Заголовок.
    *   `description` (`String`): Краткое описание.
    *   `content` (`String`): Полное содержание.
    *   `publishedAt` (`Instant`): Дата и время публикации.
    *   `url` (`String`): Ссылка на оригинальную статью.
    *   `imageUrl` (`String`): Ссылка на изображение.

*   **Поля для связей:**
    *   `author` (`User`): Автор новости (внешний ключ `author_id`).
    *   `category` (`Category`): Категория новости (внешний ключ `category_id`).
    *   `comments` (`List<Comment>`): Список комментариев к этой новости.

---

### 4. Comment (Комментарий)

*   **Связи:**
    *   **Many-to-One** с `News`: Множество комментариев относятся к одной конкретной новости.
    *   **Many-to-One** с `User`: Множество комментариев могут быть написаны одним автором.

*   **Поля сущности:**
    *   `id` (`Long`): Уникальный идентификатор.
    *   `text` (`String`): Текст комментария.
    *   `createdAt` (`Instant`): Дата и время создания комментария.

*   **Поля для связей:**
    *   `author` (`User`): Автор комментария (внешний ключ `author_id`).
    *   `news` (`News`): Новость, к которой относится комментарий (внешний ключ `news_id`).  
 
* **Репозитории**: Для каждой сущности создаем свой интерфейс-репозиторий. 
*   **`resources/schema.sql`**: Создаем SQL-скрипт с командами `CREATE TABLE` для всех наших сущностей.
    Он будет автоматически выполняться при старте и создавать структуру таблиц в БД.

---
### Этап 3: Инициализация из внешнего API

1.  **Определить точку запуска**
    *   Создаем класс-сервис компонент  `DataInitializer`, 
        который реализует интерфейс `CommandLineRunner` с единственным методом `run`. 
        Spring Boot автоматически выполнит его после старта приложения.

2.  **Добавить проверку на наличие данных**
    *   В самом начале выполнения обратиться к репозиторию (`NewsRepository`) и посчитать количество записей в таблице.
    *   Если количество больше нуля, немедленно прервать выполнение, чтобы избежать дублирования данных.

3.  **Выполнить запрос к внешнему API**
    *   Сформировать полный URL для запроса к `newsapi.org`.
    *   Использовать HTTP-клиент (`RestTemplate`) для отправки GET-запроса по этому URL.
    *   Обернуть этот шаг в блок `try-catch` для обработки возможных сетевых ошибок или недоступности API.

4.  **Преобразовать (десериализовать) ответ**
    *   Полученный от API ответ в формате JSON автоматически преобразовать в заранее подготовленные Java-объекты (DTO).
    *   Из корневого объекта ответа извлечь список статей.
    *   Проверить, что список не пустой. Если он пуст, прервать выполнение.

5.  **Подготовить связанные данные**
    *   Взять из списка только необходимое количество статей (например, первые 10).
    *   Проверить наличие в базе данных общей **категории** (например, "Tesla"). Если её нет — создать и сохранить. Если есть — использовать существующую.

6.  **Запустить цикл обработки и сохранения**
    *   Для каждой статьи из отобранного списка выполнить следующие шаги:
        *   **Обработать автора:** Проверить, существует ли в базе **пользователь** с таким именем. Если нет — создать и сохранить нового. Если есть — использовать существующего.
        *   **Создать сущность "Новость":** Создать новый объект `News`.
        *   **Заполнить поля:** Скопировать данные из статьи (заголовок, контент, дата и т.д.) в поля объекта `News`.
        *   **Установить связи:** Присвоить объекту `News` сущности автора и категории, полученные на предыдущих шагах.
        *   **Сохранить в базу:** Передать готовый объект `News` в репозиторий для сохранения (`newsRepository.save()`).

7.  **Завершить процесс**
    *   После окончания цикла вывести в лог сообщение об успешном завершении и количестве сохраненных новостей.

### Этап 4: Слой DTO (Data Transfer Objects)

Этот слой определяет **формат данных для обмена** между нашим сервером и **любым внешним приложением** 
(фронтендом, мобильным приложением и т.д.). 
Он служит "контрактом", который скрывает внутреннюю структуру базы данных и обеспечивает безопасность.

*   **Разделение DTO**: Проектируем два типа DTO для каждой сущности и размещаем их в отдельных папках `dto/request` и `dto/response`:
    *   **Request DTO**: Классы, описывающие данные, которые **приложение отправляет на сервер** для создания или обновления сущности (например, `UserRequest`). Именно в них мы размещаем аннотации валидации (`@NotBlank`, `@Size`, `@Email`) для проверки входящих данных.
    *   **Response DTO**: Классы, описывающие данные, которые **сервер отправляет в ответ**. Они содержат только публичную информацию (без паролей) и имеют структуру, удобную для **программной обработки**, включая ID. Этот ID не отображается человеку, но используется самим приложением для последующих запросов на изменение или удаление этого ресурса.
### Этап 4: Слой DTO  

Этот слой — «входные ворота» в наше API. Он отвечает за прием HTTP-запросов и отправку ответов.

*   **DTO и Маппинг**: Для каждой сущности проектируем DTO и с помощью `MapStruct` создаем мапперы для преобразования `Entity <-> DTO`.
    *   `NewsMapper` должен уметь создавать DTO с полем `commentsCount` для списков и DTO с полным списком комментариев для одиночной новости.
*   **Контроллеры**: Создаем классы с аннотацией `@RestController` (`UserController`, `NewsController` и т.д.). Их методы будут принимать запросы, вызывать сервисы и возвращать клиенту DTO.
*   **Пагинация и Фильтрация**: В `NewsController` реализуем постраничный вывод списка новостей и принимаем параметры для фильтрации по автору и категории.
*   **Валидация**: В DTO, приходящих в запросах, используем аннотации валидации (`@NotBlank`, `@Size` и т.д.), а в методах контроллеров — аннотацию `@Valid`.

---

### Этап 5: Слой бизнес-логики (Business Logic Layer)

«Сердце» нашего приложения, где реализуется вся основная логика.

*   **Сервисы**: Для каждой основной сущности создаем свой класс-сервис (`UserService`, `NewsService` и т.д.), куда внедряем репозитории.
*   **Фильтрация (Specification)**: В `NewsService` создаем метод, который принимает параметры фильтрации и с помощью `Specification` строит динамический запрос к БД.
*   **Контроль доступа (AOP)**:
    1.  Создаем аннотацию `@CheckEntityOwnership`.
    2.  Создаем Аспект (`@Aspect`), который будет выполняться `@Before` методов, помеченных этой аннотацией.
    3.  В аспекте реализуем логику проверки, что текущий пользователь является автором сущности. Если нет — выбрасываем исключение.
    4.  Помечаем аннотацией методы обновления и удаления в `NewsService` и `CommentService`.
*   **Обработка ошибок**: Создаем класс с аннотацией `@RestControllerAdvice` для глобальной обработки исключений. В нем перехватываем ошибки валидации, доступа, ненайденных сущностей и возвращаем клиенту понятный JSON с корректным HTTP-статусом.

## Этап 6: Исключения